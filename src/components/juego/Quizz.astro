---
import '../juego/Quizz.scss';
---

<html>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="questionModal" class="modal hidden">
      <div class="modal-content">
        <p id="questionText"></p>
        <div id="optionsContainer"></div>
      </div>
    </div>
  </body>
</html>

<script>
  //Dibujando el Canvas o Lienso
  const canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;

  //imagen de fondo
  const bgImagePath = '/src/assets/images/juego/nubes.jpg';

  //Imagen del Avión
  const airplaneImage = new Image();
  airplaneImage.src = '/src/assets/images/juego/avion.png';
  //Imagen de las Nubes
  const bgImage = new Image();
  bgImage.src = bgImagePath;

  //Posicion y Dimensiones del avion
  let airplaneX: number;
  let airplaneY: number;
  let airplaneWidth: number;
  let airplaneHeight: number;

  // Variables Globales
  let bgX = 0;
  const bgSpeed = 2;
  let lastTime: number = 0;
  let gamePaused = false;
  let currentQuestionIndex = 0;

  // Tamaños de referencia
  const referenceAirplaneWidth = 100;
  const referenceAirplaneHeight = 100;
  const referenceObjectWidth = 20;
  const referenceObjectHeight = 30;

  // Almacenar las respuestas
  const answers: string[] = [];

  // Tipo de Preguntas
  interface Question {
    q: string;
    options: string[];
    indice: number;
  }

  // Colección de Preguntas
  const questions: Question[] = [
    {
      q: '¿Qué tipo de entorno prefieres para tus vacaciones?',
      options: ['A: Playa', 'B: Montaña', 'C: Ciudad'],
      indice: 0,
    },
    {
      q: '¿Te gustaría explorar un destino internacional o nacional?',
      options: ['A: Internacional', 'B: Nacional', 'C: Indiferente'],
      indice: 1,
    },
    {
      q: 'What is the capital of France?',
      options: ['A: Paris', 'B: Rome', 'C: Berlin'],
      indice: 2,
    },
  ];

  // Objetos(TypeScript)
  interface GameObject {
    x: number;
    y: number;
    width: number;
    height: number;
    image: HTMLImageElement;
    isCollided: boolean;
  }

  // Colección de Objetos
  const objects: GameObject[] = [
    {
      x: 850,
      y: 200,
      width: 20,
      height: 30,
      image: new Image(),
      isCollided: false,
    },
    {
      x: 950,
      y: 200,
      width: 20,
      height: 30,
      image: new Image(),
      isCollided: true,
    },
  ];

  // Cargar la imagen del objeto a colisionar
  objects[0].image.src = '/src/assets/images/juego/obj1.png';
  objects[1].image.src = '/src/assets/images/juego/obj1.png';

  // Dimensiones del canvas
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const scaleX = canvas.width / 800;
    const scaleY = canvas.height / 600;

    airplaneWidth = referenceAirplaneWidth * Math.min(scaleX, scaleY);
    airplaneHeight = referenceAirplaneHeight * Math.min(scaleX, scaleY);

    objects.forEach((obj) => {
      obj.width = referenceObjectWidth * Math.min(scaleX, scaleY);
      obj.height = referenceObjectHeight * Math.min(scaleX, scaleY);
    });

    airplaneX = canvas.width / 2 - airplaneWidth / 2;
    airplaneY = canvas.height / 2 - airplaneHeight / 2;
  }

  // Redimensionar el canvas al cargar la página y al cambiar el tamaño de la ventana
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Función para detectar colisión
  function checkCollision(obj: GameObject): boolean {
    return (
      airplaneX < obj.x + obj.width &&
      airplaneX + airplaneWidth > obj.x &&
      airplaneY < obj.y + obj.height &&
      airplaneHeight + airplaneY > obj.y
    );
  }

  // Función para dibujar en el canvas
  function draw(time: number) {
    if (!gamePaused) {
      const deltaTime = time - lastTime;
      lastTime = time;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      bgX -= bgSpeed * (deltaTime / 16);
      if (bgX <= -canvas.width) {
        bgX = 0;
      }

      // Dibujar el fondo
      ctx.drawImage(bgImage, bgX, 0, canvas.width, canvas.height);
      ctx.drawImage(bgImage, bgX + canvas.width, 0, canvas.width, canvas.height);

      // Dibujar los objetos
      objects.forEach((obj) => {
        if (!obj.isCollided) {
          // Solo dibujar si el objeto no ha sido colisionado
          ctx.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
          if (checkCollision(obj)) {
            obj.isCollided = true; // Marcar como colisionado
            gamePaused = true; // Pausar el juego
            showQuestion(); // Mostrar la pregunta
          }
        }
      });

      // Dibujar el avión
      ctx.drawImage(airplaneImage, airplaneX, airplaneY, airplaneWidth, airplaneHeight);
    }

    requestAnimationFrame(draw);
  }

  // Mover el avión con el teclado
  function handleKeydown(event: KeyboardEvent) {
    const speed = 6;
    const key = event.key.toLowerCase();

    if (key === 'a' || key === 'arrowleft') {
      airplaneX -= speed;
    } else if (key === 'd' || key === 'arrowright') {
      airplaneX += speed;
    } else if (key === 'w' || key === 'arrowup') {
      airplaneY -= speed;
    } else if (key === 's' || key === 'arrowdown') {
      airplaneY += speed;
    }
  }

  // Mover el avión con el clic del mouse o toque en la pantalla
  function handlePointer(event: MouseEvent | TouchEvent) {
    const rect = canvas.getBoundingClientRect();
    let mouseX, mouseY;

    if (event.type === 'touchstart') {
      const touch = (event as TouchEvent).touches[0];
      mouseX = touch.clientX - rect.left;
      mouseY = touch.clientY - rect.top;
    } else {
      mouseX = (event as MouseEvent).clientX - rect.left;
      mouseY = (event as MouseEvent).clientY - rect.top;
    }

    // Actualizar la posición del avión
    airplaneX = mouseX - airplaneWidth / 2;
    airplaneY = mouseY - airplaneHeight / 2;
  }

  // Mostrar las preguntas
  function showQuestion() {
    const question = questions[currentQuestionIndex];
    const modal = document.getElementById('questionModal') as HTMLElement;
    const questionText = document.getElementById('questionText') as HTMLElement;
    const optionsContainer = document.getElementById('optionsContainer') as HTMLElement;

    optionsContainer.innerHTML = '';

    questionText.textContent = question.q;

    question.options.forEach((option, index) => {
      const button = document.createElement('button');
      button.className = 'option-button';
      button.textContent = option;
      button.onclick = () => handleOptionClick(index);

      optionsContainer.appendChild(button);
    });

    modal.classList.remove('hidden');
  }

  // Manejar la selección de opciones
  function handleOptionClick(selectedIndex: number) {
    const question = questions[currentQuestionIndex];

    const currentAnswer = selectedIndex === question.indice ? 'correct' : 'incorrect';
    answers.push(currentAnswer);

    const modal = document.getElementById('questionModal') as HTMLElement;
    modal.classList.add('hidden');

    resumeGame();
  }

  // Función para continuar el juego
  function resumeGame() {
    gamePaused = false;

    if (currentQuestionIndex < questions.length - 1) {
      currentQuestionIndex++;
      objects[currentQuestionIndex].isCollided = false;
    }

    if (currentQuestionIndex >= questions.length) {
      // TODO: Mostrar aterrizaje
    }
  }

  // Iniciar el bucle de animación
  requestAnimationFrame(draw);

  // Manejar eventos de teclado
  window.addEventListener('keydown', handleKeydown);

  // Manejar clics de mouse y toques en pantalla
  canvas.addEventListener('mousedown', handlePointer);
  canvas.addEventListener('touchstart', handlePointer);
</script>
